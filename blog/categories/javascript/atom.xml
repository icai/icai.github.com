<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 泛前端开发]]></title>
  <link href="http://blog.w3cub.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://blog.w3cub.com/"/>
  <updated>2020-05-27T17:13:10+00:00</updated>
  <id>http://blog.w3cub.com/</id>
  <author>
    <name><![CDATA[Terry Cai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[浅谈服务端渲染(SSR)的几种形式]]></title>
    <link href="http://blog.w3cub.com/blog/2019/07/01/ssr-types/"/>
    <updated>2019-07-01T08:48:43+00:00</updated>
    <id>http://blog.w3cub.com/blog/2019/07/01/ssr-types</id>
    <content type="html"><![CDATA[<p>在好久好久之前，前端的概念是模糊的。前端就是页面仔，切图仔。前端的任务就是把html跟js写好，然后丢给后端套数据。基本传统的MVC，smarty View。</p>
<pre><code>assign-&gt;('data', $data)
</code></pre>
<p>这些也给后端做了。或者前端就丢给UI（美工）做，前端是不存在的。</p>

<!--more -->

<p>[[back] -&gt;[view]]-&gt; [front end]</p>

<p>但是随着移动端的兴起，开始流行前后分离。</p>

<p>后端渲染模版的这一层就给省略掉了.<br />
变成前后分离。其实所谓的后端渲染，也就是渲染首屏幕。<br />
[back] -&gt;-&gt; [front and view]</p>

<p>但是又因为前后分离对搜索引擎爬虫不太友好。想当年，做网站的人都十分在意一个东西，就是Alexa排名，后者国内的百度排名，cnzz排名等等。毕竟那个时候风头的人都会看一下你的网站alexa是多少。其实这种指标就是反应了一个网站的活跃度。不如说，你说你的网站有几百万用户，但是别人查了一下这种排名，尽然几千万，搜索引擎收录几乎没有。这样做你认为会有信服力吗？</p>

<p>当然SEO需求大部分面向C端的。<strong>面向后台管理系统</strong>的当然就没有那么在乎了。</p>

<p>为了解决SPA  bad SEO 问题。例如后台服务器拦截拦截特定爬虫进行SEO hack，批量提交Sitemap 等等的手段。简单的说，你想告诉搜索引擎链接，然后爬虫跳进来，进行相应的SEO hack 投食时渲染。</p>

<p><strong>我们把这种形式叫做 前后分离 + 后端辅助（SPA hack回滚）。</strong></p>

<p>但是随着node，babel的快速发展，浏览器快速迭代，前端工作天天调试兼容的时代过去了。变成了后端服务器 + 前端服务器这种架构。[back server] -&gt;-&gt; [[view-server]front server]。<br />
前端的地位重要多了。同构这个概念于是被提出了。当时前端们就设想 <strong>后端渲染跟前端异步渲染可以重用</strong>。比如一个循环的列表，里面的item 模版可以被前端重用。到后来，随着 react vue 等框架开始流行，nextjs诞生了。这个阶段，主要是SPA的改进。node服务器把SEO需要的功能都做了。<br />
既然node可以写server层，那么为什么不可以后端也用node呢。当然这用什么语言写后端，并不影响前端。</p>

<p><strong>我们把这个形式称做，SPA + SSR前端渲染。</strong></p>

<p>既然可以SSR前端渲染，为什么不可以后端渲染呢！当然服务器的权利就只剩下了 node。<br />
又开始 后端的 Route -&gt; Controller -&gt; Model-&gt; View.<br />
这时候的 View 就变成了react 或者 vue. 其实就把当年的后端模版替换成了 前端框架模版，model输出的数据就变成 View的prop或者data 变量。</p>

<p><strong>我们把这种形式称为  SSR后端渲染。</strong></p>

<p>到头来，你会发现，走了一圈，又回到了原点。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript混淆与解混淆的那些事儿]]></title>
    <link href="http://blog.w3cub.com/blog/2019/04/01/js-confusion/"/>
    <updated>2019-04-01T05:48:43+00:00</updated>
    <id>http://blog.w3cub.com/blog/2019/04/01/js-confusion</id>
    <content type="html"><![CDATA[<p>像软件加密与解密一样，javascript的混淆与解混淆同属于同一个范畴。道高一尺，魔高一丈。没有永恒的黑，也没有永恒的白。一切都是资本市场驱动行为，现在都流行你能为人解决什么问题，这个概念。那么市场究竟能容纳多少个能解决这种问题的利益者。JS没有秘密。</p>

<p>其实本人不赞成javascript进行hash混淆处理，一拖慢运行时速度，二体积大。JS代码前端可获取，天生赋予“开源”属性，都可以在chrome devTools下查看。JS非压缩性混淆完全违法前端优化准则。</p>

<!-- more -->

<p>目前网络上可以搜索的JS混淆工具不外乎以下几种：</p>

<p><a href="http://blog.w3cub.com/tools/jspacker/">eval混淆</a>，也是最早JS出现的混淆加密，据说第一天就被破解，修改一下代码，alert一下就可以破解了。这种方法从出生的那天就失去了意义。其实JS加密（混淆）是相对于可读性而言的，其实真正有意义的就是压缩型混淆uglify这一类，即可减少体重，也可减少可读性。</p>

<p>但是，也不能排除部分商业源代码使用hash类型混淆源代码，比如 miniui 使用的<a href="https://sourceforge.net/projects/jsintegration/files/tools/_%20JSA-20071021/">JSA加密</a>, fundebug使用的<a href="https://obfuscator.io/">javascript-obfuscator</a>。</p>

<p>下面通过代码来说明 JSA加密 和 javascript-obfuscator 的区别：</p>

<p>要混淆的代码：</p>

<pre><code class="language-js">function logG(message) {
  console.log('\x1b[32m%s\x1b[0m', message); 
}
function logR(message) {
  console.log('\x1b[41m%s\x1b[0m', message); 
}
logG('logR');
logR('logG');

</code></pre>

<p>通过<a href="https://sourceforge.net/projects/jsintegration/files/tools/_%20JSA-20071021/">JSA加密</a>混淆后生成的代码</p>

<pre><code>function o00($){console.log("\x1b[32m%s\x1b[0m",$)}function o01($){console.log("\x1b[41m%s\x1b[0m",$)}o00("logR");o01("logG")

</code></pre>
<p>然后再<a href="https://beautifier.io/">beautifier</a>一下：</p>

<pre><code class="language-js">function o00($) {
  console.log("\x1b[32m%s\x1b[0m", $)
}

function o01($) {
  console.log("\x1b[41m%s\x1b[0m", $)
}
o00("logR");
o01("logG")

</code></pre>

<p>可以发现，其实没有做什么什么修改，只是做了一些变量替换。想还原也比较简单的。这里就不拿它来做代表，也没有什么人用。</p>

<p>通过<a href="https://obfuscator.io/">javascript-obfuscator</a>混淆后生成的代码</p>

<pre><code class="language-js">var _0xd6ac=['[41m%s[0m','logG','log'];(function(_0x203a66,_0x6dd4f4){var _0x3c5c81=function(_0x4f427c){while(--_0x4f427c){_0x203a66['push'](_0x203a66['shift']());}};_0x3c5c81(++_0x6dd4f4);}(_0xd6ac,0x6e));var _0x5b26=function(_0x2d8f05,_0x4b81bb){_0x2d8f05=_0x2d8f05-0x0;var _0x4d74cb=_0xd6ac[_0x2d8f05];return _0x4d74cb;};function logG(_0x4f1daa){console[_0x5b26('0x0')]('[32m%s[0m',_0x4f1daa);}function logR(_0x38b325){console[_0x5b26('0x0')](_0x5b26('0x1'),_0x38b325);}logG('logR');logR(_0x5b26('0x2'));

</code></pre>

<p>再<a href="https://beautifier.io/">beautifier</a>一下：</p>

<pre><code class="language-js">var _0xd6ac = ['[41m%s[0m', 'logG', 'log'];
(function(_0x203a66, _0x6dd4f4) {
  var _0x3c5c81 = function(_0x4f427c) {
    while (--_0x4f427c) {
      _0x203a66['push'](_0x203a66['shift']());
    }
  };
  _0x3c5c81(++_0x6dd4f4);
}(_0xd6ac, 0x6e));
var _0x5b26 = function(_0x2d8f05, _0x4b81bb) {
  _0x2d8f05 = _0x2d8f05 - 0x0;
  var _0x4d74cb = _0xd6ac[_0x2d8f05];
  return _0x4d74cb;
};

function logG(_0x4f1daa) {
  console[_0x5b26('0x0')]('[32m%s[0m', _0x4f1daa);
}

function logR(_0x38b325) {
  console[_0x5b26('0x0')](_0x5b26('0x1'), _0x38b325);
}
logG('logR');
logR(_0x5b26('0x2'));
</code></pre>

<p>这个复杂得多，但是分析一下你会发现，其实多了一个字典，所有方法变量，都有可能存在字典中，调用时先调用字典还原方法名变量再执行。<br />
其实入口都是变量的规则。</p>

<p>字典函数：</p>

<pre><code class="language-js">var _0xd6ac = ['[41m%s[0m', 'logG', 'log'];
(function(_0x203a66, _0x6dd4f4) {
  var _0x3c5c81 = function(_0x4f427c) {
    while (--_0x4f427c) {
      _0x203a66['push'](_0x203a66['shift']());
    }
  };
  _0x3c5c81(++_0x6dd4f4);
}(_0xd6ac, 0x6e));
var _0x5b26 = function(_0x2d8f05, _0x4b81bb) {
  _0x2d8f05 = _0x2d8f05 - 0x0;
  var _0x4d74cb = _0xd6ac[_0x2d8f05];
  return _0x4d74cb;
};

</code></pre>

<p>通过以上发现，我们可以把JS混淆归结为三类，分别是 eval类型，hash类型，压缩类型。而压缩类型，是目前前端性能优化的常用工具，以<a href="https://www.npmjs.com/package/uglify-js">uglify</a>为代表。</p>

<p>常用的前端压缩优化工具：</p>

<p>JavaScript:</p>
<ul>
  <li><a href="https://github.com/babel/minify">babel-minify</a></li>
  <li><a href="https://github.com/terser-js/terser">terser</a></li>
  <li><a href="https://github.com/mishoo/UglifyJS2">uglify-js</a></li>
  <li><a href="https://github.com/mishoo/UglifyJS2/tree/harmony">uglify-es</a></li>
  <li><a href="https://www.npmjs.com/package/google-closure-compiler">Google Closure Compiler</a></li>
  <li><a href="http://yui.github.io/yuicompressor/">YUI Compressor</a></li>
</ul>

<p>CSS:</p>
<ul>
  <li><a href="https://github.com/postcss/postcss">PostCSS</a></li>
  <li><a href="https://github.com/jakubpawlowicz/clean-css">clean-css</a></li>
  <li><a href="https://github.com/css/csso">CSSO</a></li>
  <li><a href="http://yui.github.io/yuicompressor/">YUI Compressor</a></li>
</ul>

<p>HTML:</p>
<ul>
  <li><a href="https://www.npmjs.com/package/html-minifier">html-minifier</a></li>
</ul>

<p>从工具流(workflow) 来看，不论是 webpack 还是 gulp ，目前javascript最流行工具还是uglify。</p>

<p>相应的解混淆工具：</p>

<ul>
  <li>
    <p>eval对应的解混淆工具, 随便百度都可以搜索到，如<a href="http://blog.w3cub.com/tools/jspacker/">jspacker</a></p>
  </li>
  <li>
    <p>JSA对应的解混淆工具<a href="https://github.com/jscck/unjsa">unjsa</a></p>
  </li>
  <li>
    <p><a href="https://obfuscator.io/">javascript-obfuscator</a>对应的解混淆工具<a href="https://github.com/jscck/crack.js">crack.js</a></p>
  </li>
  <li>
    <p>压缩类型uglify对应的工具<a href="https://github.com/eth-sri/UnuglifyJS">UnuglifyJS</a>，在线版<a href="http://www.jsnice.org/">jsnice</a></p>
  </li>
</ul>

<p>解混淆策略其实是依据生成代码规律编写，不外乎观察特征分析，再观察特征分析，不断调整。都是手办眼见功夫。</p>

<p>都没有什么难度可言，有的就是耐性。比如<a href="https://obfuscator.io/">javascript-obfuscator</a>对应的解混淆工具可以<br />
分解为N因子问题：</p>

<p>如何查询function的作用域？<br />
预执行变量替换可能存在类型？<br />
…</p>

<p>如：</p>

<pre><code class="language-js">var _0xd6ac = ['[41m%s[0m', 'logG', 'log'];
(function(_0x203a66, _0x6dd4f4) {
  var _0x3c5c81 = function(_0x4f427c) {
    while (--_0x4f427c) {
      _0x203a66['push'](_0x203a66['shift']());
    }
  };
  _0x3c5c81(++_0x6dd4f4);
}(_0xd6ac, 0x6e));
var _0x5b26 = function(_0x2d8f05, _0x4b81bb) {
  _0x2d8f05 = _0x2d8f05 - 0x0;
  var _0x4d74cb = _0xd6ac[_0x2d8f05];
  return _0x4d74cb;
};

function logG(_0x4f1daa) {
  console[_0x5b26('0x0')]('[32m%s[0m', _0x4f1daa);
}

function logR(_0x38b325) {
  console[_0x5b26('0x0')](_0x5b26('0x1'), _0x38b325);
}
logG('logR');
logR(_0x5b26('0x2'));
</code></pre>

<p>要还原成</p>

<pre><code class="language-js">function logG(message) {
  console.log('\x1b[32m%s\x1b[0m', message); 
}
function logR(message) {
  console.log('\x1b[41m%s\x1b[0m', message); 
}
logG('logR');
logR('logG');

</code></pre>
<p>第一步你总得知道字典函数，然后执行字典函数 <code>_0x5b26('0x0')</code> 还原成 <code>log</code>.</p>

<p>那么就好办了，写代码的事。<br />
如 https://github.com/jscck/crack.js/blob/master/crack.js</p>

<p>还原后，如何重构代码，那么你还得知道代码生成之前是通过什么工具打包的webpack? 还是？</p>

<p>如webpack 的各种封装头和尾<br />
https://webpack.js.org/configuration/output/#expose-a-variable</p>

<pre><code class="language-js">(function webpackUniversalModuleDefinition(root, factory) {
  if(typeof exports === 'object' &amp;&amp; typeof module === 'object')
    module.exports = factory();
  else if(typeof define === 'function' &amp;&amp; define.amd)
    define([], factory);
  else if(typeof exports === 'object')
    exports['MyLibrary'] = factory();
  else
    root['MyLibrary'] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
  return _entry_return_;
});
</code></pre>

<p>假如再深入一点，可能会涉及到JS语法解释器, AST抽象语法树</p>

<p>目前涉及到 JS语法解释器, AST抽象语法树的功能如下：</p>

<p><a href="https://prepack.io/">prepack</a>, <a href="http://esprima.org/">esprima</a>, <a href="https://babeljs.io/">babel</a></p>

<p>或者可以阅读《编程语言实现模式》，涉及到 <a href="https://github.com/antlr/antlr4">antlr4</a>。</p>

<p>当然也可以通过esprima等工具来做解混淆，只是工作量大一点，值不值的问题。</p>

<p>对于未来，JS商业源码加密的方向可能<a href="https://webassembly.org/">webassembly</a>，先在服务端编译成wasm，源码就能真正的闭源。</p>

<p>有人的地方就有路，有混淆的地方就有解混淆，目前机器学习编程响应的解混淆工具也做的相当出色，比如</p>

<p><a href="16"><img src="https://www.sri.inf.ethz.ch/assets/images/sri-logo.svg" alt="Secure, Reliable, and Intelligent Systems Lab" width="136" /></a></p>

<p>Machine Learning for Programming 产品<br />
<a href="17">nice2predict</a>，<a href="9">jsnice</a> …<br />
查看 https://www.sri.inf.ethz.ch/research/plml</p>

<h2 id="拓展参考">拓展参考</h2>

<h3 id="ast抽象语法树">AST抽象语法树</h3>

<p>为什么额外说一下AST抽象语法树，因为你可以 input-&gt; ast -&gt; output Anything。</p>

<p>比如你jsx转换小程序模版语法，这样你就可以用react语法来写小程序，如Taro。<br />
mpvue, wepy, postcss …… 这些都是通过AST进行构建转换的工具，es6 -&gt; es5, babel 都是使用AST。</p>

<p>AST抽象语法树大致流程：</p>

<p>Input 生成 AST tree</p>

<p>然后通过AST类型断言进行相应的转换</p>

<p>http://esprima.org/demo/parse.html</p>

<h3 id="反编译工具全集">反编译工具全集</h3>

<p>小程序</p>

<p>https://github.com/qwerty472123/wxappUnpacker</p>

<p><code>推荐.Net、C# 逆向反编译四大工具利器</code></p>

<p>https://www.cnblogs.com/ldc218/p/8945892.html</p>

<p>2018年支持java8的Java反编译工具汇总<br />
https://blog.csdn.net/yannqi/article/details/80847354</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to properly uninstall Service Worker？]]></title>
    <link href="http://blog.w3cub.com/blog/2018/06/01/how-to-properly-uninstall-service-worker/"/>
    <updated>2018-06-01T15:10:43+00:00</updated>
    <id>http://blog.w3cub.com/blog/2018/06/01/how-to-properly-uninstall-service-worker</id>
    <content type="html"><![CDATA[<p>如何正确地卸载Service Worker？</p>

<p>以下链接， Google Developers Service Worker工作原理：<br />
https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#updates</p>

<p>但是假如某一天你网站不需要 Service Worker，如何正确地卸载呢？</p>

<p>以下以 create-react-app 为例子:</p>

<!-- more -->

<ul>
  <li>千万不要直接从服务器干掉 service-worker.js （sw.js），或者去掉 sw-precache-webpack-plugin 插件直接build。</li>
</ul>

<ol>
  <li>假如你服务器是增量更新的，<br />
<img src="https://user-images.githubusercontent.com/1061012/40846563-8b73ce96-65ec-11e8-8781-e374c38c77ba.png" alt="image" /></li>
</ol>

<p>那么你的服务器文件service-worker.js永远都在，假如用户之前访问了你的网站，并且用户不清缓存的话，cache就永远都在了，你怎么更新，用户还是访问旧的版本。</p>

<ol>
  <li>你说把你服务器的 service-worker.js 干掉，那么假如用户之前访问过呢？本地有一份service-worker.js，那么按照service-worker工作原理，本地一直生效，不管你网站怎么更新，用户看到的依旧是旧的内容。</li>
</ol>

<p>service-worker.js</p>

<pre><code class="language-js">
'use strict';

var precacheConfig = [
["/index.html","a16310808c31e9e89b8d72aa2ddb058c"],
["/plugin.dll.0cf858ac.js","7268282b6a4415b541c4658c1478febc"],
["/vendor.dll.830d2c27.js","097dfeec5dda4f277752cb36b5d548ee"]
];
var cacheName = 'sw-precache-v3-sw-precache-webpack-plugin-' + (self.registration ? self.registration.scope : '');


var ignoreUrlParametersMatching = [/^utm_/];



var addDirectoryIndex = function (originalUrl, index) {
    var url = new URL(originalUrl);
    if (url.pathname.slice(-1) === '/') {
      url.pathname += index;
    }
    return url.toString();
  };

var cleanResponse = function (originalResponse) {
    // If this is not a redirected response, then we don't have to do anything.
    if (!originalResponse.redirected) {
      return Promise.resolve(originalResponse);
    }

    // Firefox 50 and below doesn't support the Response.body stream, so we may
    // need to read the entire body to memory as a Blob.
    var bodyPromise = 'body' in originalResponse ?
      Promise.resolve(originalResponse.body) :
      originalResponse.blob();

    return bodyPromise.then(function(body) {
      // new Response() is happy when passed either a stream or a Blob.
      return new Response(body, {
        headers: originalResponse.headers,
        status: originalResponse.status,
        statusText: originalResponse.statusText
      });
    });
  };

var createCacheKey = function (originalUrl, paramName, paramValue,
                           dontCacheBustUrlsMatching) {
    // Create a new URL object to avoid modifying originalUrl.
    var url = new URL(originalUrl);

    // If dontCacheBustUrlsMatching is not set, or if we don't have a match,
    // then add in the extra cache-busting URL parameter.
    if (!dontCacheBustUrlsMatching ||
        !(url.pathname.match(dontCacheBustUrlsMatching))) {
      url.search += (url.search ? '&amp;' : '') +
        encodeURIComponent(paramName) + '=' + encodeURIComponent(paramValue);
    }

    return url.toString();
  };

var isPathWhitelisted = function (whitelist, absoluteUrlString) {
    // If the whitelist is empty, then consider all URLs to be whitelisted.
    if (whitelist.length === 0) {
      return true;
    }

    // Otherwise compare each path regex to the path of the URL passed in.
    var path = (new URL(absoluteUrlString)).pathname;
    return whitelist.some(function(whitelistedPathRegex) {
      return path.match(whitelistedPathRegex);
    });
  };

var stripIgnoredUrlParameters = function (originalUrl,
    ignoreUrlParametersMatching) {
    var url = new URL(originalUrl);
    // Remove the hash; see https://github.com/GoogleChrome/sw-precache/issues/290
    url.hash = '';

    url.search = url.search.slice(1) // Exclude initial '?'
      .split('&amp;') // Split into an array of 'key=value' strings
      .map(function(kv) {
        return kv.split('='); // Split each 'key=value' string into a [key, value] array
      })
      .filter(function(kv) {
        return ignoreUrlParametersMatching.every(function(ignoredRegex) {
          return !ignoredRegex.test(kv[0]); // Return true iff the key doesn't match any of the regexes.
        });
      })
      .map(function(kv) {
        return kv.join('='); // Join each [key, value] array into a 'key=value' string
      })
      .join('&amp;'); // Join the array of 'key=value' strings into a string with '&amp;' in between each

    return url.toString();
  };


var hashParamName = '_sw-precache';
var urlsToCacheKeys = new Map(
  precacheConfig.map(function(item) {
    var relativeUrl = item[0];
    var hash = item[1];
    var absoluteUrl = new URL(relativeUrl, self.location);
    var cacheKey = createCacheKey(absoluteUrl, hashParamName, hash, /\.\w{8}\./);
    return [absoluteUrl.toString(), cacheKey];
  })
);

function setOfCachedUrls(cache) {
  return cache.keys().then(function(requests) {
    return requests.map(function(request) {
      return request.url;
    });
  }).then(function(urls) {
    return new Set(urls);
  });
}

self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(cacheName).then(function(cache) {
      return setOfCachedUrls(cache).then(function(cachedUrls) {
        return Promise.all(
          Array.from(urlsToCacheKeys.values()).map(function(cacheKey) {
            // If we don't have a key matching url in the cache already, add it.
            if (!cachedUrls.has(cacheKey)) {
              var request = new Request(cacheKey, {credentials: 'same-origin'});
              return fetch(request).then(function(response) {
                // Bail out of installation unless we get back a 200 OK for
                // every request.
                if (!response.ok) {
                  throw new Error('Request for ' + cacheKey + ' returned a ' +
                    'response with status ' + response.status);
                }

                return cleanResponse(response).then(function(responseToCache) {
                  return cache.put(cacheKey, responseToCache);
                });
              });
            }
          })
        );
      });
    }).then(function() {
      
      // Force the SW to transition from installing -&gt; active state
      return self.skipWaiting();
      
    })
  );
});

self.addEventListener('activate', function(event) {
  var setOfExpectedUrls = new Set(urlsToCacheKeys.values());

  event.waitUntil(
    caches.open(cacheName).then(function(cache) {
      return cache.keys().then(function(existingRequests) {
        return Promise.all(
          existingRequests.map(function(existingRequest) {
            if (!setOfExpectedUrls.has(existingRequest.url)) {
              return cache.delete(existingRequest);
            }
          })
        );
      });
    }).then(function() {
      
      return self.clients.claim();
      
    })
  );
});


self.addEventListener('fetch', function(event) {
  if (event.request.method === 'GET') {
    // Should we call event.respondWith() inside this fetch event handler?
    // This needs to be determined synchronously, which will give other fetch
    // handlers a chance to handle the request if need be.
    var shouldRespond;

    // First, remove all the ignored parameters and hash fragment, and see if we
    // have that URL in our cache. If so, great! shouldRespond will be true.
    var url = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);
    shouldRespond = urlsToCacheKeys.has(url);

    // If shouldRespond is false, check again, this time with 'index.html'
    // (or whatever the directoryIndex option is set to) at the end.
    var directoryIndex = 'index.html';
    if (!shouldRespond &amp;&amp; directoryIndex) {
      url = addDirectoryIndex(url, directoryIndex);
      shouldRespond = urlsToCacheKeys.has(url);
    }

    // If shouldRespond is still false, check to see if this is a navigation
    // request, and if so, whether the URL matches navigateFallbackWhitelist.
    var navigateFallback = '/index.html';
    if (!shouldRespond &amp;&amp;
        navigateFallback &amp;&amp;
        (event.request.mode === 'navigate') &amp;&amp;
        isPathWhitelisted(["^(?!\\/__).*"], event.request.url)) {
      url = new URL(navigateFallback, self.location).toString();
      shouldRespond = urlsToCacheKeys.has(url);
    }

    // If shouldRespond was set to true at any point, then call
    // event.respondWith(), using the appropriate cache key.
    if (shouldRespond) {
      event.respondWith(
        caches.open(cacheName).then(function(cache) {
          return cache.match(urlsToCacheKeys.get(url)).then(function(response) {
            if (response) {
              return response;
            }
            throw Error('The cached response that was expected is missing.');
          });
        }).catch(function(e) {
          // Fall back to just fetch()ing the request if some unexpected error
          // prevented the cached response from being valid.
          console.warn('Couldn\'t serve response for "%s" from cache: %O', event.request.url, e);
          return fetch(event.request);
        })
      );
    }
  }
});

</code></pre>

<p>index.js 入口文件</p>

<p>https://github.com/facebook/create-react-app/blob/next/packages/react-scripts/template/src/index.js</p>

<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import * as serviceWorker from './serviceWorker';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: http://bit.ly/CRA-PWA
serviceWorker.unregister();
//----vs-----
serviceWorker.register({
    onUpdate: async (registration) =&gt; {
        await registration.update();
        message.info("网站更新完成, 请刷新页面: " + moment().format('YYYY-MM-DD HH:mm:ss'), 0.5, () =&gt; {
            window.location.reload();
        });
    },
    onSuccess: () =&gt; {}
});



</code></pre>

<p>假如你引入了serviceWorker文件, 并发布了，</p>

<p>https://github.com/facebook/create-react-app/blob/next/packages/react-scripts/template/src/serviceWorker.js</p>

<h3 id="正确做法是">正确做法是：</h3>
<p><code>serviceWorker.register();</code> 改成 <code>serviceWorker.unregister();</code> <br />
但是同时千万要记住 要保留  sw-precache-webpack-plugin 去做webpack 构建（目的是为了生成新的service-worker.js，触发更新)。按照人的<strong>既定思维</strong>，既然不要了，那么当然要移除。</p>

<p>假如移除了  sw-precache-webpack-plugin,  你怎么 生成新版本的 service-worker.js，还有，没有新版本 service-worker.js 又怎么会更新你的代码了，这里似乎出现<strong>双重陷阱</strong>，但是当你理解了service-worker.js 生命周期原理后，一切都可以理解。</p>

<h3 id="最后总结">最后总结：</h3>
<p>在入口加入:</p>

<p>serviceWorker.unregister();</p>

<p>service-worker.js 文件 依旧需要更新。</p>

<p>假如真的不想引入 sw-precache-webpack-plugin 做webpack构建的话，请把服务器上面的<br />
service-worker.js  <code>precacheConfig</code> 清空</p>
<pre><code class="language-js">var precacheConfig = [
];
</code></pre>

<p>https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#opting-out-of-caching</p>

<p>If you would prefer not to enable service workers prior to your initial production deployment, then remove the call to registerServiceWorker() from src/index.js.</p>

<p>If you had previously enabled service workers in your production deployment and have decided that you would like to disable them for all your existing users, you can swap out the call to registerServiceWorker() in src/index.js first by modifying the service worker import:</p>
<pre><code>import { unregister } from './registerServiceWorker';
</code></pre>

<p>and then call unregister() instead. After the user visits a page that has unregister(), the service worker will be uninstalled. Note that depending on how /service-worker.js is served, it may take up to 24 hours for the cache to be invalidated.</p>

<p>create-react-app 提示的测试服务器<br />
<img src="https://user-images.githubusercontent.com/1061012/40872668-b5ae9a72-6684-11e8-9d37-ba7d3fed427e.png" alt="image" /><br />
对service-worker.js会有HTTP缓存，部署简单nginx 服务器进行测试</p>

<pre><code class="language-conf">    server {
       listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

       location / {
           root   D:\yourproject\build;
           index  index.html index.htm;
           # proxy_no_cache 1;
           add_header Cache-Control "no-cache";
           try_files $uri $uri/ /index.html;
       }

       location /service\-worker\.js {
            expires -1;
            add_header Pragma "no-cache";
       }
    }

</code></pre>

<pre><code>serviceWorker.register({
    onUpdate: async (registration) =&gt; {
        await registration.update(); // 这里很重要
        message.info("网站更新完成, 请刷新页面: " + moment().format('YYYY-MM-DD HH:mm:ss'), 0.5, () =&gt; {
            window.location.reload();
        });
    },
    onSuccess: () =&gt; {}
});

</code></pre>

<h3 id="延伸阅读">延伸阅读：</h3>

<p>https://lavas.baidu.com/guide/v2/advanced/service-worker#%E6%B3%A8%E5%86%8C-service-worker-%E6%89%A9%E5%B1%95<br />
注册 Service Worker (扩展)</p>

<p>提示：这部分内容由 Lavas 内部处理，并不需要开发者进行参与，仅仅作为解答开发者疑问的扩展阅读存在。</p>

<p>Service Worker 编写完成后，还需要进行注册才能真正生效。常规的注册代码能够在各类 Service Worker 教程或文章中找到，但在实际项目中有一个不得不考虑的问题，使得我们必须对注册代码进行一些改动，那就是 Service Worker 更新 的问题。</p>

<p>https://github.com/lavas-project/sw-register-webpack-plugin</p>

<p>离线指南<br />
https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network</p>

<p>假如熟悉Service Worker 缓存机制的话，那么为什么要卸载呢 ？</p>

<p>本文 ： https://github.com/icai/icai.github.io/issues/1</p>

<p>-EOF-</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《html5数据推送应用开发》读书摘要]]></title>
    <link href="http://blog.w3cub.com/blog/2017/08/06/sse-data-push-note/"/>
    <updated>2017-08-06T09:18:14+00:00</updated>
    <id>http://blog.w3cub.com/blog/2017/08/06/sse-data-push-note</id>
    <content type="html"><![CDATA[<p>书很薄，在图书馆瞄了一下，知识点不多。<br />
基本上第二章基本讲完，其他讲解都是一些擦边的，兼容性，安全性，……<br />
可以总结为如下：</p>

<!-- more -->

<p>《Data Push Apps with HTML5 SSE》 读书摘要</p>

<h2 id="摘要">摘要</h2>

<ul>
  <li>EventSource方法 new EventSource(“url”);</li>
  <li>MIME类型text/event-stream</li>
  <li>数据传输格式”data:” + new Date().toISOString() + “\n\n”;</li>
</ul>

<h2 id="sse示例">SSE示例</h2>

<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;Basic SSE Example&lt;/title&gt;
&lt;script src="//code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;pre id="x"&gt;Initializing...&lt;/pre&gt;
&lt;script&gt;
    var es = new EventSource("basic_sse.php");
    es.addEventListener("message", function(e){
        $("#x").append("\n" + e.data);
    },false);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="language-javascript">var http = require("http"),
    fs = require("fs");
var port = parseInt(process.argv[2] || 1234);
http.createServer(function(request, response) {
    console.log("Client connected:" + request.url);
    if (request.url != "/sse") {
        fs.readFile("basic_sse.html", function(err, file) {
            response.writeHead(200, { 'Content-Type': 'text/html' });
            var s = file.toString(); //file is a buffer
            s = s.replace("basic_sse.php", "sse");
            response.end(s);
        });
        return;
    }
    //Below is to handle SSE request. It never returns.
    response.writeHead(200, { "Content-Type": "text/event-stream" });
    var timer = setInterval(function() {
        var content = "data:" + new Date().toISOString() + "\n\n";
        var b = response.write(content);
        if (!b) console.log("Data got queued in memory (content=" + content + ")");
        else console.log("Flushed! (content=" + content + ")");
    }, 1000);
    request.connection.on("close", function() {
        response.end();
        clearInterval(timer);
        console.log("Client closed connection. Aborting.");
    });
}).listen(port);
console.log("Server running at http://localhost:" + port);
</code></pre>

<h2 id="兼容性">兼容性</h2>

<p>startEventSource()</p>

<ul>
  <li>Basically all Firefox and Chromea</li>
  <li>Desktop Safari 5.0+</li>
  <li>iOS Safari 4.0+</li>
  <li>Android 4.4+ (earlier where Chrome is default browser)</li>
  <li>Chrome for Android (all versions)</li>
  <li>Firefox for Android (all versions)</li>
  <li>Opera since 11.0</li>
  <li>Opera Mobile since 11.1</li>
  <li>BlackBerry since 7.0</li>
</ul>

<p>startXHR()</p>

<ul>
  <li>IE10+</li>
  <li>Firefox 3.6 (and earlier)</li>
  <li>Safari 3.x</li>
  <li>Android 4.1 to 4.3 (unless Chrome is default browser)</li>
  <li>Android 3.x</li>
</ul>

<p>startIframe()</p>

<ul>
  <li>IE8</li>
  <li>IE9</li>
</ul>

<p>~~startLongpoll()</p>
<ul>
  <li>IE6</li>
  <li>IE7</li>
  <li>Android 2.x</li>
  <li>Anything else not in the preceding list that has Ajax support<br />
~~</li>
</ul>

<p>~~(none)</p>
<ul>
  <li>Any browser with JavaScript disabled<br />
~~</li>
</ul>

<p>~~a Technically since Firefox 6 and Chrome 6, but they have been auto-updating since Firefox 4, and Chrome since it came out<br />
of beta, so you can reasonably expect no one is still using versions that do not support SSE.<br />
~~</p>

<p>书本代码，书本代码，书本代码。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/DarrenCook/ssebook">书本代码</a></li>
  <li><a href="https://caniuse.com/#feat=eventsource">eventsource浏览器支持</a></li>
  <li><a href="https://www.w3.org/TR/eventsource/">https://www.w3.org/TR/eventsource/</a></li>
  <li><a href="https://html.spec.whatwg.org/multipage/server-sent-events.html">HTML Living Standard: Server-sent events</a></li>
  <li><a href="https://github.com/Yaffle/EventSource">a polyfill for http://www.w3.org/TR/eventsource/</a></li>
</ul>

<h2 id="其他参考">其他参考</h2>

<ul>
  <li><a href="https://www.ibm.com/developerworks/library/wa-http-server-push-with-websocket-sse/">HTTP server push with WebSocket and SSE</a></li>
  <li><a href="https://www.zhihu.com/question/27498235">Ajax长轮询与服务器推的长连接的区别是？</a></li>
  <li><a href="http://goeasy.io/cn/demos">商业化示例</a></li>
</ul>

<p>-EOF-</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模糊匹配查询正则表达式探究]]></title>
    <link href="http://blog.w3cub.com/blog/2015/07/15/fuzzy-scoring-regex-mayhem-zh/"/>
    <updated>2015-07-15T14:09:43+00:00</updated>
    <id>http://blog.w3cub.com/blog/2015/07/15/fuzzy-scoring-regex-mayhem-zh</id>
    <content type="html"><![CDATA[<p>Autocompletion is never an entirely solved problem. Can anyone really say what on earth a user typing “uni” into a country input field actually intends to select? It could match any of these:</p>

<p>自动完成一直都是一个没完没了的问题。谁能准确地说出当一个地球人在一个国家输入框输入“uni”打算选什么？可能会出现以下情况：</p>

<ul>
  <li>Tanzania, [<strong>U</strong>][<strong>n</strong>][<strong>i</strong>]ted Republic of</li>
  <li>[<strong>U</strong>][<strong>n</strong>][<strong>i</strong>]ted Arab Emirates</li>
  <li>[<strong>U</strong>][<strong>n</strong>][<strong>i</strong>]ted Kingdom</li>
  <li>[<strong>U</strong>][<strong>n</strong>][<strong>i</strong>]ted States</li>
  <li>T[<strong>u</strong>][<strong>n</strong>][<strong>i</strong>]sia</li>
</ul>

<p>Of course, it’s probably not the last one, but that right there is a human intuition that we often forget to instil into these UI interactions.</p>

<p>当然，这可能不是最后一个，但人类的直觉通常会忘记灌输这些UI交互。</p>

<!-- more -->

<p>We can divine what the user <em>probably</em> intends most of the time but it’ll always be a game of heuristics. Most solutions shy away from this game, opting instead to match the query letter-for-letter in each potential value, and this is usually sufficient, but without any other logic not only will “la” match “Latvia” but also “Angola”. And usually “Ltvia” will match nothing whatsoever, even though it’s seemingly obvious what the user is trying to type.</p>

<p>我们可以推断用户在这上面花费的时间，显然这是一个启发式游戏。大多数解决方案都是尝试匹配字母之间可能潜在的值，通常已经足够了，“la” 没有任何逻辑，会匹配 “Latvia” 也会匹配 “Angola”。但绝不会匹配 “Ltvia”，尽管“Ltvia”看似是用户想要的输入类型。</p>

<p>If you try implementing a fuzzy matcher to solve this, the first revelation is that you can’t just boolean-match the query against the data like so many solutions do. You need to score each potential match. Hopefully, in the case of country selection, you end up with a sensible subset of countries that match the query to some reasonable degree. This scoring is necessary so that you know what you’re putting at the top of the list. When typing “U”, the user expects Ukraine or Uzbekistan sooner than Mauritius or Sudan, for example.</p>

<p>假如你想用模糊匹配去解决这个问题。首先，你不能像往常那样用boolean匹配去请求查询数据。你需要计算每个存在匹配的分数。 在选择国家情况下，你最终需要请求匹配查询一些合符逻辑的合理的国家子集。那么这分数是非常有必要的，以便我们可以把它们排到列表的顶部。</p>

<p>（译注, boolean匹配 <a href="https://github.com/bevacqua/fuzzysearch">https://github.com/bevacqua/fuzzysearch</a>）</p>

<p>Oddly, if you looked at the most common autocompletion widget out there (jQuery UI), it <a href="http://jsfiddle.net/2c11xknm/embedded/result,js,html">doesn’t appear</a> to follow this intuition.</p>

<p>奇怪的是，假如见过最常用的jQuery UI 自动完成（autocompletion）插件，他并没有解决这个问题。</p>

<p>Even the most <a href="http://baymard.com/labs/country-selector">graceful</a> solutions tend to avoid the muddiness of dealing with mistakes like “untied states” or “leichtenstein”. Sure, the likeliness of a person having to type the name of a country they aren’t intimately familiar with is probably quite low, but people still make mistakes.</p>

<p>即使是最优雅的解决方案，都趋向于忽视模糊处理错误，像“untied states” （united states） 和 “leichtenstein” （liechtenstein ）。当然， 就像一个人输入一个国家的名字，他们不熟悉这个国家可能性是非常很低。但人们仍然会犯错误。</p>

<p>I’ve been intrigued by this topic for quite a while and it’s why I originally made <a href="https://github.com/padolsey/relevancy.js">relevancy.js</a>. It solves the problem quite well, I think, and it does so in a pretty transparent way, with scores applied for various qualities such as the index of the query within the target string (“king” scores higher than “dom” in “kingdom”, for example), but it’s still a quite a lot of code for such a tiny part of an overall user experience.</p>

<p>我一直被这个话题吸引了很长时间，也是我写 <a href="https://github.com/padolsey/relevancy.js">relevancy.js</a> 的原因。它可以很好地处理类似问题，我想，他的原理是非常显而易见的，就是通过分数去区分不同品质（把分数应用于品质）例如，目标字符串查询的索引(正如在查询“kingdom” “的时候，king”的分数比 “dom”高)。但这还是需要相当多的代码去实现这小部分，相对于这样一个整体用户体验的而言。</p>

<p>I have once again been playing with this problem (thanks to a certain <a href="https://twitter.com/codepo8/status/572863924887945216">tweet</a>) and have so wanted to come up with something stupefyingly graceful.</p>

<p>我又再一次遇上了这个问题（谢谢 <a href="https://twitter.com/codepo8/status/572863924887945216">tweet</a> 的肯定），我想可以写的更加优雅。</p>

<p>It all starts with a scratch in back of your mind — the one that tells you that your time has come. The <a href="http://xkcd.com/208/">world requires you</a> to use regular expressions.</p>

<p>一切从头开始在你的脑海里，这告诉你的时间到了。<a href="http://xkcd.com/208/">world requires you</a> （世界需要你） 用正则表达式。</p>

<p><strong>Warning:</strong> I don’t sincerely recommend doing any of this. It’s just a bit of fun. It’s probably an inefficient, unreliable, obscure and ultimately foolish endeavour!</p>

<p>Warning： 别分心，不然效率极低的，bebebe～～～</p>

<h2 id="lets-begin">Let’s begin!</h2>

<p>##我们入正题：</p>

<p>A static France might look like this:</p>

<p>静态字符串France 正则：</p>

<pre><code>/^France$/
</code></pre>

<p>A more lenient France might be less sensitive to its case:</p>

<p>不区分大小写：</p>

<pre><code>/^france$/i
</code></pre>

<p>We could then allow the characters to be optional too:</p>

<p>我们也可以允许字符是可选的</p>

<pre><code>/^f?r?a?n?c?e?$/i
</code></pre>

<p>This would match “f” and “franc” and “FaE”, etc.</p>

<p>这会匹配 “f”， “franc” 和 “FaE”等等。</p>

<p>But… users make even more grievous mistakes sometimes, and our regular expression should be able to handle those. So let’s add a single character of leniency between each legitimate character, and at the beginning and end of the string:</p>

<p>但…… 用户有时犯更严重的错误，我们的正常表达应该能够处理这些错误。因此，让我们在每一个合理的字母之间加上一个宽容的字符在每个字符的前后。</p>

<pre><code>/^.?f?.?r?.?a?.?n?.?c?.?e?.?$/i
</code></pre>

<p>But then this would allow contiguous mistakes like “fafafafa”. We only want to allow a <em>single</em> incorrect mistake after each successfully entered character. For this we can use groups to force each character to be matched and a lazy quantifier on the mistake character to ensure that legitimate characters get to successfully match.</p>

<p>但当这允许连续错误像“fafafafa”，我们只允许一个单一的错误在每个正确输入字符之后。为此我们可以使用分组强制每个字符匹配和懒惰匹配的错误的字符串，确保合法字符可以成功匹配。</p>

<p>So:</p>

<pre><code>/f.?otherStuff/
</code></pre>

<p>Becomes:</p>

<pre><code>/(?:f.??)?otherStuff/
</code></pre>

<p>In English: Try to match <code>f</code> followed by <code>otherStuff</code>. If impossible then try to match any character after <code>f</code> but before <code>otherStuff</code>. (This is why lazy quantifiers (e.g. <code>??</code>) are so useful!)</p>

<p>就是说，尝试匹配跟在otherStuff之前的f。如果不可能的话，尝试匹配任何在“f” 之后，在“otherStuff” 之前的字符。</p>

<p>The entire regex would become:</p>

<p>完整的正则表达式会变成：</p>

<pre><code>/^(?:.(?=f))?(?:f.??)?(?:r.??)?(?:a.??)?(?:n.??)?(?:c.??)?(?:e.??)?$/i
</code></pre>

<p>We should probably capture each individual match (<code>f</code> should be <code>(f)</code>) so that we can analyze the result and score it appropriately.</p>

<p>我们可能需要捕获每个单独的匹配(<code>f</code> 应该是<code>(f)</code>) ，以便我们可以分析结果并适当地评分。</p>

<pre><code>var r = /^(?:(f).??)?(?:(r).??)?(?:(a).??)?(?:(n).??)?(?:(c).??)?(?:(e).??)?$/i

'f$R-aN_cEx'.match(r);
// =&gt; ["f$R-aN_cEx", "f", "R", "a", "N", "c", "E"]
</code></pre>

<p>The regular expression, broken down:</p>

<p>正则表达式解释：</p>

<pre><code>/
  ^       # Start of string

  (?:     # Non-captured group（非捕获）
    (f)   # Match and capture 'f' （匹配并捕获"f"）
    .??   # Followed lazily by any character （懒惰匹配跟随字符）
  )?      # Entire group is optional （组可选）

  (?:     # Non-captured group
    (r)   # Match and capture 'f'
    .??   # Followed lazily by any character
  )?      # Entire group is optional

  ...     # Etc.

  $       # End of string
/i
</code></pre>

<p><em>A quick note</em>: <em>lazy</em> or <em>lazily</em> in the context of regular expressions simply means that that thing will be intentionally excluded from the first match attempt and will only be used if the subsequent regular expression is unsuccessful without it.</p>

<p>小便签：正则表达式中懒惰匹配是指……</p>

<p>One caveat with the above regex is that it doesn’t allow a mistake to be at the beginning of the string. We could fix this with a lookahead to the effect of “allow a mistake here as long as its followed by a non-mistake” but since “non-mistake” could effectively be any character in the legitimate string it’s easier to just make allowances for that initial mistake in each group. Additionally, we probably want to capture every single mistake, in addition to legitimate characters. Here’s our next iteration:</p>

<p>一个需要注意的是，上面的正则表达式，它不允许在字符串的开头有错误。我们可以修复这个前瞻错误通过 “允许犯错误，只要它跟在一个非错误后面”， 但由于 “非错误” 可以有效地在合法字符串中的任何字符，使得它更容易在每个组中出现所允许的初始错误。此外，除了合法的字符，我们还可能要捕捉每一个错误。下面是我们的实现：</p>

<pre><code>/
  ^         # Start of string

  (?:       # Non-captured group

    (^.)?   # Captured optional mistake at the beginning of the string
            # ===============================================

    (f)     # Match and capture 'f'
    (.??)   # Followed lazily by any character (captured)
  )?        # Entire group is optional

  ...     # Etc.

  $       # End of string
/i
</code></pre>

<p>The check <code>(^.)?</code> has to be specified in each group, to account for mistakes that don’t involve “f”, like “krance” or “ttance”, etc.</p>

<p>检查<code>(^.)?</code>必须每组都指定, 以便考虑错误不涉及到 “f”, 就像 “krance” 和 “ttance”, 等等。</p>

<p>Since we’re aiming to genericize this entire mess, we should create a generator that assembles the regular expression given any piece of text:</p>

<p>我们的目标是是要去处理这一类问题，所以我们需要构建一个完整的生成器去组装将给定的文本集合的正则表达式。</p>

<pre><code>function makeFuzzyRegex(string) {

  if (!string) { return /^$/; }

  // Escape any potential special characters:
  var cleansed = string.replace(/\W/g, '\\$&amp;');

  return RegExp(
    '^' +
      cleansed.replace(
        // Find every escaped and non-escaped char:
        /(\\?.)/g,
        // Replace with fuzzy character matcher:
        '(?:(^.)?($1)(.??))?'
      ) +
    '$',
    'i'
  );
}

makeFuzzyRegex('omg');
// =&gt; /^(?:(^.)?(o)(.??))?(?:(^.)?(m)(.??))?(?:(^.)?(g)(.??))?$/i
</code></pre>

<p>This regex matched against ‘_o-m*g!’ produces:</p>

<pre><code>[
  // Full match:
  "_o-m*g!",

  // Captures:
  "_",           // Mistake
  "o",           // Legit
  "-",           // Mistake

  undefined,     // Void mistake
  "m",           // Legit
  "*",           // Mistake

  undefined,     // Void mistake
  "g",           // Legit
  "!"            // Mistake
]
</code></pre>

<p>The captures are in groups of three, with every second capture being the legitimate character (case-insensitive), and with every first and third potentially being mistakes.</p>

<p>捕获是在三组，每组捕获都是合法性（不区分大小写），并与每组第一和第三个字符都可能潜在错误。</p>

<p>We can then loop through these captures and apply weights as we see fit.</p>

<p>我们可以循环这些捕捉和应用权重作为我们合适的分数。</p>

<pre><code>var fullMatch = makeFuzzyRegex('omg').exec('_o-m*g!');
var captures = fullMatch.slice(1); // Get captures specifically
var score = 0;

for (var i = 0, l = captures.length; i &lt; l; i += 3) {
  if (captures[i]) score -= 1;
  if (captures[i+1]) score += 10;
  if (captures[i+2]) score -= 1;
}

score; // =&gt; 26
</code></pre>

<p>That scoring is quite arbitrary, but we’ve at least prescribed our wish to score successes more than we punish mistakes (10 vs 1).</p>

<p>这计算是十分随意的，但是我们至少指定我们的愿望比我们惩罚的错误更成功(10 vs 1)。</p>

<p>We can start to play with the heuristics of this if we wrap it all up:</p>

<p>我们把它封装起来，让Ta溜溜：</p>

<pre><code>function createFuzzyScorer(text) {

  var matcher = makeFuzzyRegex(text);

  return function(query) {
    var match = matcher.exec(query);

    if (!match) return 0;

    var captures = match.slice(1);
    var score = 0;

    for (var i = 0, l = captures.length; i &lt; l; i += 3) {
      if (captures[i]) score -= 1;
      if (captures[i+1]) score += 10;
      if (captures[i+2]) score -= 1;
    }

    return score;
  };

  function makeFuzzyRegex(string) {

    if (!string) { return /^$/; }

    // Escape any potential special characters:
    var cleansed = string.replace(/\W/g, '\\$&amp;');

    return RegExp(
      '^' +
        cleansed.replace(
          // Find every escaped and non-escaped char:
          /(\\?.)/g,
          // Replace with fuzzy character matcher:
          '(?:(^.)?($1)(.??))?'
        ) +
      '$',
      'i'
    );
  }
}
</code></pre>

<p>Our first attempt isn’t too bad:</p>

<p>我们的第一次尝试并不太坏：</p>

<pre><code>var score = createFuzzyScorer('omg');

score('omg');     // =&gt; 30
score('xOmg');    // =&gt; 29
score('.o.m.g.'); // =&gt; 26
score('om');      // =&gt; 20
score('og');      // =&gt; 20
score('o');       // =&gt; 10
score('nope');    // =&gt; 0
</code></pre>

<p>These seem like sensible enough scores, generally, but we’re more interested in autocompletion, and so there’s an obvious predictive element there. If a user types ‘o’ then that should probably score higher than ‘g’ if we’re testing against ‘omg’, but with the above mechanism they both receive a standard 10:</p>

<p>这似乎是可感知的足够的分数，一般，但我们在自动完成更感兴趣，所以有一个明显的预测元素的存在。当我们我们测试‘omg’时，如果用户键入”o”那应该得分高于”g”，但上述方法都接受标准的10：</p>

<pre><code>var score = createFuzzyScorer('omg');

score('o'); // =&gt; 10
score('g'); // =&gt; 10
</code></pre>

<p>We can fix this by applying a higher weight to matches that appear earlier in the string:</p>

<p>我们可以用更高的权重来解决字符串中较早出现的匹配问题：</p>

<pre><code>// The scoring loop:
for (var i = 0, l = captures.length; i &lt; l; i += 3) {
  if (captures[i]) score -= 0.1;
  if (captures[i+1]) score += (l - i) / l; // the magic
  if (captures[i+2]) score -= 0.1;
}
</code></pre>

<p>Now the score given for any singular legitimate match will decrease as the index (<code>i</code>) increases. Here are the results:</p>

<p>现在任何奇异的合法的匹配的得分将会递减随着指数（i）增加。这里是结果：</p>

<pre><code>var score = createFuzzyScorer('omg');

score('omg');     // =&gt; 1.99
score('xOmg');    // =&gt; 1.90
score('om');      // =&gt; 1.66
score('.o.m.g.'); // =&gt; 1.59
score('og');      // =&gt; 1.33
score('o');       // =&gt; 1.00
score('nope');    // =&gt; 0.00
</code></pre>

<p>This is getting closer to our intuition. The next step would be to try to create a real autocompletion widget. I’ve done it so I know that we’ll want to make one more change. The problem with our scoring right now is that it’ll award legitimate characters relative to the length of the string. But when comparing scores across multiple subject strings, this approach seems broken.</p>

<p>这是越来越接近我们的直觉。下一步将努力创造一个真正的自动完成功能部件。我已经这样做了，所以我知道，我们将要做一个改变。现在我们分值的问题是，奖励合法的字符相对于字符串的长度。但是，当比较多个同类字符串的分数时，这种方法似乎被打破。</p>

<pre><code>createFuzzyScorer('RuneScript')('Ru'); // 1.9
createFuzzyScorer('Ruby')('Ru');       // 1.7
</code></pre>

<p>These should both score equally, as “Ru” is just as likely to become “Ruby” as it is to become “RuneScript”. To achieve this we should only take into account the index, and make the weight of any scoring decision inversely proportional to that index, in this case via an exponential taper (<code>pow(index, -2)</code>).</p>

<p>显然，分数应该相等，因为 “Ru” 推演成 “Ruby” 和 “RuneScript” 是一样. 为了实现这一点，我们应该考虑到该指数，并使任何得分决定的权重与指数成反比，在这种情况下，通过指数锥度 (<code>pow(index, -2)</code>)</p>

<pre><code>// The scoring loop:
for (var i = 0, l = captures.length; i &lt; l; i += 3) {
  var relevancyOfCharacter = Math.pow(i + 1, -2);
  if (captures[i]) score -= relevancyOfCharacter * 0.1;
  if (captures[i+1]) score += relevancyOfCharacter * 1;
  if (captures[i+2]) score -= relevancyOfCharacter * 0.1;
}
</code></pre>

<p><em>(Final version of <code>createFuzzyScorer</code> available <a href="https://gist.github.com/padolsey/a27a32d5859a71403b10">as a gist</a>.)</em></p>

<p><strong><a href="http://jsbin.com/wanetemare/1/edit?js,output">See this demo using programming languages as the dataset</a></strong>. Try intentionally misspelling something (jawascript), or missing out characters (jaascit), or just going a little crazy (jahskt). It works beautifully.</p>

<p><strong><a href="http://jsbin.com/wanetemare/1/edit?js,output">在数据集用编程语言实现查看demo</a></strong>. 尝试拼写错误（jawascript），或者丢失字母（jaascit）或者输入一些类似的（jahskt）， 它依然工作得很漂亮。</p>

<p>To achieve speedy sorting, a fuzzy scorer is created for every single value before the user types anything:</p>

<p>为了实现快速排序， 每一个单一的值的模糊分数应该在用户输入之前被创建：</p>

<pre><code>var data = PROGRAMMING_LANGUAGES.map(function(lang, i) {
  return {
    actualValue: lang,
    score: createFuzzyScorer(lang),
    i: i,
    toString: function() { return lang; }
  };
});
</code></pre>

<p>This means we can iterate through <code>data</code> on every relevant input event, and call the <code>score()</code>method with the current query. We can then bundle this into a <em>filter-&gt;sort-&gt;slice</em> flow to get our list of sensible suggestions:</p>

<p>这意味着我们可以遍历每个相关的输入事件的 data ，调用 score() 方法来实现当前查询。我们可以把这变成一个 <em>filter-&gt;sort-&gt;slice</em> 得出我们列出的有判断力的建议：</p>

<pre><code>var sorted = data.filter(function(item) {

  // Get rid of any very unlikely matches (and cache the score!)
  return (item._cachedScore = item.score(query)) &gt;= .5;

}).sort(function(a, b) {

  var as = a._cachedScore;
  var bs = b._cachedScore;

  // Sort by score, and if score is equal, then by original index:
  // (We would typically return 0 in that case but some engines don't stable-sort)
  return as &gt; bs ? -1 : as == bs &amp;&amp; a.i &lt; b.i ? -1 : 1;

}).slice(0, 10); // We only need the top 10...
</code></pre>

<p>And.. we’re done. It’s never really finished though: you’ll find endless tweaks that can be made to the scorer to make it more believably resemble human-like intuition.</p>

<p>我们做到了，虽然它从来没有真正完成，你会发现很多的调整，使得分数更加人工智能。</p>

<p>For those wanting to test the resulting country autocompletion interaction: <strong><a href="http://jsbin.com/lejucikiha/1/edit?js,output">See the demo</a></strong>.</p>

<p>对于那些想要测试国家自动完成返回值交互的，<strong><a href="http://jsbin.com/lejucikiha/1/edit?js,output">See the demo</a></strong>.</p>

<p>I guess, despite my initial warning, I wouldn’t actually mind using this in production, as long as there were a decent number of unit tests. I’d probably also assemble the regular expressions on the server and serve them up as literals. It’s also worth mentioning that almost everything in this post has been exploring the fuzzy-matching of very short strings in small datasets. Even in the case of the country demo, to get more applicable results, I broke up long names into the component parts and then scored against each. E.g.</p>

<p>我想，尽管我最初的忠告，我不介意使用这个在生产，只要做一些数量的单位测试。我可能也组装正则表达式在服务器并为提供服务。值得一提的是，几乎所有的这篇文章都在探索小数据集上的模糊匹配。即使在国家输入案例的演示，以获得更适用的结果，我折断了长的名字，组成部分，然后对每一个得分。例如</p>

<pre><code>// E.g. Macedonia, the Former Yugoslav Republic of:
var scorers = [
  "Macedonia, the Former Yugoslav Republic of",
  "Macedonia",
  "the",
  "former",
  "yugoslav",
  "republic",
  "of"
].map(createFuzzyScorer);
// Etc.
</code></pre>

<p>And this would be terribly inefficient on a larger scale, so with any dataset longer than a list of countries you’re probably best to explore <a href="http://en.wikipedia.org/wiki/Trie">Trie</a>-based approaches to autocompletion.</p>

<p>And with that, I’ll shut-up and wish you merry regex’ing!</p>

<p>然而这在大规模扫描下是非常低效的，所以任何数据集比的国家名单长的，你可能最好的探究 <a href="http://en.wikipedia.org/wiki/Trie">Trie</a>-based 方法 来处理自动完成。然后，我会闭嘴， wish you merry regex’ing!</p>

<p>译者注：</p>

<p>文中及其评论提到的资源：</p>

<p><a href="https://github.com/padolsey/relevancy.js">https://github.com/padolsey/relevancy.js</a></p>

<p><a href="https://github.com/bevacqua/fuzzysearch">https://github.com/bevacqua/fuzzysearch</a></p>

<p><a href="https://github.com/gf3/Levenshtein">https://github.com/gf3/Levenshtein</a></p>

<p>作者github：<a href="https://github.com/padolsey">https://github.com/padolsey</a></p>

<p>译者：主要用到正则懒惰匹配去实现<code>真值</code>线性回归。you are truly, how much truly you are!</p>

<p>就是通过匹配度分数进行排序，而不是单单的boolean 值指定，再a-z 排序输出，</p>

<p><a href="https://github.com/bevacqua/fuzzysearch">https://github.com/bevacqua/fuzzysearch</a>所用的方法，你只能在true or false 之间选择，而padolsey所用的方法字样引入了权重概念更加智能，但是在大规模数据下是非常低效的。另外在作者的博客评论中也提到的 <a href="https://github.com/gf3/Levenshtein">https://github.com/gf3/Levenshtein</a>， 可以自行wiki一下。</p>

<hr />

<p>最后如有漏译，错译，欢迎指正。</p>

]]></content>
  </entry>
  
</feed>
