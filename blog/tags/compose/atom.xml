<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Compose | 泛前端开发]]></title>
  <link href="http://blog.w3cub.com/blog/tags/compose/atom.xml" rel="self"/>
  <link href="http://blog.w3cub.com/"/>
  <updated>2019-09-24T15:28:05+00:00</updated>
  <id>http://blog.w3cub.com/</id>
  <author>
    <name><![CDATA[Terry Cai]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker Compose入门]]></title>
    <link href="http://blog.w3cub.com/blog/2018/12/23/docker-compose-gettingstarted/"/>
    <updated>2018-12-23T05:48:43+00:00</updated>
    <id>http://blog.w3cub.com/blog/2018/12/23/docker-compose-gettingstarted</id>
    <content type="html"><![CDATA[<pre><code>预计阅读时间：10分钟
</code></pre>

<p>在此页面上，您将构建一个在Docker Compose上运行的简单Python Web应用程序。该应用程序使用Flask框架并在Redis中维护一个命中计数器。虽然该示例使用Python，但即使您不熟悉它，此处演示的概念也应该是可以理解的。</p>

<h2 id="预先准备">预先准备</h2>

<p>确保您已经安装了 <a href="https://docs.docker.com/install/">Docker Engine</a> 和 <a href="https://docs.docker.com/compose/install/">Docker Compose</a>. 您不需要安装Python或Redis，因为两者都是由Docker镜像提供的。</p>

<!-- more -->

<h2 id="第一步-setup">第一步: Setup</h2>

<p>定义应用程序依赖(dependencies).</p>

<ol>
  <li>
    <p>为项目创建一个目录:</p>

    <pre><code>$ mkdir composetest
$ cd composetest
</code></pre>
  </li>
  <li>
    <p>在项目目录中创建一个名为<code>app.py</code>的文件并粘贴如下:</p>
  </li>
</ol>

<pre><code class="language-python">import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)

def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr('hits')
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)

@app.route('/')
def hello():
    count = get_hit_count()
    return 'Hello World! I have been seen {} times.\n'.format(count)

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
</code></pre>

<p>In this example, <code>redis</code> is the hostname of the redis container on the application’s network. We use the default port for Redis, <code>6379</code>.</p>

<blockquote>
  <p>Handling transient errors</p>

  <p>Note the way the <code>get_hit_count</code> function is written. This basic retry loop lets us attempt our request multiple times if the redis service is not available. This is useful at startup while the application comes online, but also makes our application more resilient if the Redis service needs to be restarted anytime during the app’s lifetime. In a cluster, this also helps handling momentary connection drops between nodes.</p>
</blockquote>

<ol>
  <li>
    <p>在项目目录中创建另一个名为<code>requirements.txt</code>的文件并粘贴如下:</p>

    <pre><code>flask
redis
</code></pre>
  </li>
</ol>

<h2 id="第二步-创建一个dockerfile">第二步: 创建一个Dockerfile</h2>

<p>在此步骤中，您将编写一个构建包含Python应用程序所需的所有依赖项，包括Python本身的Docker镜像的Dockerfile。</p>

<p>在项目目录中，创建一个名为<code>Dockerfile</code>的文件并粘贴以下内容：</p>

<pre><code>FROM python:3.4-alpine
ADD . /code
WORKDIR /code
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
</code></pre>

<p>这里告诉Docker要做什么:</p>

<ul>
  <li>Build an image starting with the Python 3.4 image.</li>
  <li>Add the current directory <code>.</code> into the path <code>/code</code> in the image.</li>
  <li>Set the working directory to <code>/code</code>.</li>
  <li>Install the Python dependencies.</li>
  <li>Set the default command for the container to <code>python app.py</code>.</li>
</ul>

<p>更多关于如何编写Dockerfiles的信息，请查看 <a href="https://docs.docker.com/engine/tutorials/dockerimages/#building-an-image-from-a-dockerfile">Docker user guide</a> 和 <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a>.</p>

<h2 id="第三步-在compose文件中定义服务">第三步: 在Compose文件中定义服务</h2>

<p>在项目目录中创建一个名为<code>docker-compose.yml</code>的文件并粘贴以下内容:</p>
<pre><code class="language-yaml">version: '3'
services:
  web:
    build: .
    ports:
     - "5000:5000"
  redis:
    image: "redis:alpine"

</code></pre>

<p>这Compose文件定义了两个服务, <code>web</code> and <code>redis</code>. The <code>web</code> service:</p>

<ul>
  <li>Uses an image that’s built from the <code>Dockerfile</code> in the current directory.</li>
  <li>Forwards the exposed port 5000 on the container to port 5000 on the host machine. We use the default port for the Flask web server, <code>5000</code>.</li>
</ul>

<p>The <code>redis</code> service uses a public <a href="https://registry.hub.docker.com/_/redis/">Redis</a> image pulled from the Docker Hub registry.</p>

<h2 id="第四步-使用compose构建和运行您的应用程序">第四步: 使用Compose构建和运行您的应用程序</h2>

<ol>
  <li>从项目目录中，运行<code>docker-compose up</code>启动应用程序.</li>
</ol>

<pre><code class="language-bash">$ docker-compose up
Creating network "composetest_default" with the default driver
Creating composetest_web_1 ...
Creating composetest_redis_1 ...
Creating composetest_web_1
Creating composetest_redis_1 ... done
Attaching to composetest_web_1, composetest_redis_1
web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
redis_1  | 1:C 17 Aug 22:11:10.480 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
redis_1  | 1:C 17 Aug 22:11:10.480 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started
redis_1  | 1:C 17 Aug 22:11:10.480 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
web_1    |  * Restarting with stat
redis_1  | 1:M 17 Aug 22:11:10.483 * Running mode=standalone, port=6379.
redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
web_1    |  * Debugger is active!
redis_1  | 1:M 17 Aug 22:11:10.483 # Server initialized
redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
web_1    |  * Debugger PIN: 330-787-903
redis_1  | 1:M 17 Aug 22:11:10.483 * Ready to accept connections
</code></pre>

<p>Compose拉取Redis镜像，为您的代码构建镜像，并启动您定义的服务。 在这种情况下，代码在构建时静态复制到映像中。</p>

<ol>
  <li>
    <p>在浏览器输入 <code>http://0.0.0.0:5000/</code> 查看应用运行情况.</p>

    <p>If you’re using Docker natively on Linux, Docker for Mac, or Docker for Windows, then the web app should now be listening on port 5000 on your Docker daemon host. Point your web browser to <code>http://localhost:5000</code> to find the <code>Hello World</code>message. If this doesn’t resolve, you can also try <code>http://0.0.0.0:5000</code>.</p>

    <p>If you’re using Docker Machine on a Mac or Windows, use <code>docker-machine ip MACHINE_VM</code> to get the IP address of your Docker host. Then, open <code>http://MACHINE_VM_IP:5000</code> in a browser.</p>

    <p>You should see a message in your browser saying:</p>

    <pre><code>Hello World! I have been seen 1 times.
</code></pre>

    <p><img src="https://docs.docker.com/compose/images/quick-hello-world-1.png" alt="hello world in browser" /></p>
  </li>
  <li>
    <p>刷新网页.</p>

    <p>The number should increment.</p>

    <pre><code>Hello World! I have been seen 2 times.
</code></pre>

    <p><img src="https://docs.docker.com/compose/images/quick-hello-world-2.png" alt="hello world in browser" /></p>
  </li>
  <li>
    <p>切换到另一个终端窗口，然后键入<code>docker image ls</code>列出本地镜像.</p>

    <p>Listing images at this point should return <code>redis</code> and <code>web</code>.</p>

    <pre><code>$ docker image ls
REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
composetest_web         latest              e2c21aa48cc1        4 minutes ago       93.8MB
python                  3.4-alpine          84e6077c7ab6        7 days ago          82.5MB
redis                   alpine              9d8fa9aa0e5b        3 weeks ago         27.5MB
</code></pre>

    <p>You can inspect images with <code>docker inspect &lt;tag or id&gt;</code>.</p>
  </li>
  <li>
    <p>通过在另一个终端在项目目录中运行<code>docker-compose down</code>, 或者在启动应用程序的终端中按CTRL + C 来停止应用程序.</p>
  </li>
</ol>

<h2 id="第五步-编辑compose文件以添加绑定装载">第五步: 编辑Compose文件以添加绑定装载</h2>

<p>编辑项目目录中的<code>docker-compose.yml</code>为<code>web</code>服务添加 <a href="https://docs.docker.com/engine/admin/volumes/bind-mounts/">bind mount</a> :</p>
<pre><code class="language-yaml">version: '3'
services:
  web:
    build: .
    ports:
     - "5000:5000"
    volumes:
     - .:/code
  redis:
    image: "redis:alpine"

</code></pre>
<p>The new <code>volumes</code> key 把项目目录（当前目录）挂载到容器内的<code>/ code</code>允许您动态修改代码，而无需重建映像</p>

<h2 id="第六步-使用compose-re-build并运行应用程序">第六步: 使用Compose Re-build并运行应用程序</h2>

<p>在项目目录中，键入<code>docker-compose up</code>以使用更新的Compose文件构建应用程序，然后运行它。</p>
<pre><code class="language-bash">$ docker-compose up
Creating network "composetest_default" with the default driver
Creating composetest_web_1 ...
Creating composetest_redis_1 ...
Creating composetest_web_1
Creating composetest_redis_1 ... done
Attaching to composetest_web_1, composetest_redis_1
web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
...
</code></pre>

<p>Check the <code>Hello World</code> message in a web browser again, and refresh to see the count increment.</p>

<blockquote>
  <p>Shared folders, volumes, and bind mounts</p>

  <ul>
    <li>
      <p>If your project is outside of the <code>Users</code> directory (<code>cd ~</code>), then you need to share the drive or location of the Dockerfile and volume you are using. If you get runtime errors indicating an application file is not found, a volume mount is denied, or a service cannot start, try enabling file or drive sharing. Volume mounting requires shared drives for projects that live outside of <code>C:\Users</code> (Windows) or <code>/Users</code> (Mac), and is required for <em>any</em> project on Docker for Windows that uses <a href="https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers-beta-feature">Linux containers</a>. For more information, see <a href="https://docs.docker.com/docker-for-windows/#shared-drives">Shared Drives</a> on Docker for Windows, <a href="https://docs.docker.com/docker-for-mac/#file-sharing">File sharing</a> on Docker for Mac, and the general examples on how to <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">Manage data in containers</a>.</p>
    </li>
    <li>
      <p>If you are using Oracle VirtualBox on an older Windows OS, you might encounter an issue with shared folders as described in this <a href="https://www.virtualbox.org/ticket/14920">VB trouble ticket</a>. Newer Windows systems meet the requirements for <a href="https://docs.docker.com/docker-for-windows/install/">Docker for Windows</a> and do not need VirtualBox.</p>
    </li>
  </ul>
</blockquote>

<h2 id="第七步-更新应用程序">第七步: 更新应用程序</h2>

<p>由于应用程序代码现在使用卷安装到容器中，因此您可以更改其代码并立即查看更改，而无需重建映像.</p>

<ol>
  <li>
    <p>Change the greeting in <code>app.py</code> and save it. For example, change the <code>Hello World!</code> message to <code>Hello from Docker!</code>:</p>

    <pre><code>return 'Hello from Docker! I have been seen {} times.\n'.format(count)
</code></pre>
  </li>
  <li>
    <p>Refresh the app in your browser. The greeting should be updated, and the counter should still be incrementing.</p>

    <p><img src="https://docs.docker.com/compose/images/quick-hello-world-3.png" alt="hello world in browser" /></p>
  </li>
</ol>

<h2 id="第八步-尝试一些其他命令">第八步: 尝试一些其他命令</h2>

<p>如果你想在后台运行你的服务, 你可以在<code>docker-compose up</code>命令后面添加 <code>-d</code> (for “detached” mode)，使用<code>docker-compose ps</code>查看当前正在运行的内容:</p>

<pre><code class="language-bash">$ docker-compose up -d
Starting composetest_redis_1...
Starting composetest_web_1...

$ docker-compose ps
Name                 Command            State       Ports
-------------------------------------------------------------------
composetest_redis_1   /usr/local/bin/run         Up
composetest_web_1     /bin/sh -c python app.py   Up      5000-&gt;5000/tcp
</code></pre>

<p><code>docker-compose run</code>命令允许您为服务运行一次性命令。例如，查看<code>web</code>服务可用的环境变量:</p>

<pre><code>$ docker-compose run web env
</code></pre>

<p>可以通过<code>docker-compose --help</code>查看更多其他可用命令  . 您还可以为bash和zsh shell安装 <a href="https://docs.docker.com/compose/completion/">command completion</a>,以查看可用的命令.</p>

<p>如果您使用<code>docker-compose up -d</code>启动Compose，请在完成后停止服务:</p>

<pre><code>$ docker-compose stop
</code></pre>

<p>您可以使用<code>down</code>命令将所有内容放下，完全删除容器. 传递<code>--volumes</code>也可以删除Redis容器使用的数据挂载:</p>

<pre><code>$ docker-compose down --volumes
</code></pre>

<p>到这里, 您已经了解了Compose如何工作的基础知识.</p>

<h2 id="接下来">接下来</h2>

<ul>
  <li>Next, try the quick start guide for <a href="https://docs.docker.com/compose/django/">Django</a>, <a href="https://docs.docker.com/compose/rails/">Rails</a>, or <a href="https://docs.docker.com/samples/library/wordpress/">WordPress</a></li>
  <li><a href="https://docs.docker.com/compose/reference/">Explore the full list of Compose commands</a></li>
  <li><a href="https://docs.docker.com/compose/compose-file/">Compose configuration file reference</a></li>
  <li>
    <p>To learn more about volumes and bind mounts, see <a href="https://docs.docker.com/engine/admin/volumes/">Manage data in Docker</a></p>

    <p>documentation, docs, docker, compose, orchestration, containers</p>
  </li>
</ul>

<hr />

<p>Terry edit on <a href="http://markdown.w3cub.com/">markdown编辑</a></p>
]]></content>
  </entry>
  
</feed>